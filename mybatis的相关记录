org.apache.ibatis.builder：使用了建造者模式。建造者模式用于生产对象。与工厂模式不同的是工厂模式是直接就new出来的，而建造者模式是通过流式编程的风格让用户可以参与这个过程，具备一定的定制化能力。
org.apache.ibatis.binding：使用了动态代理。生产一个mapper的接口类。
org.apache.ibatis.mapping：策略模式。根据不同的入参实例化不同的类。
org.apache.ibatis.executor：模板模式。定义一个整体的流程，有些固定的流程让基类去实现。而不固定的流程由子类去实现。但是整体的流程方向由基类固定好了。
org.apache.ibatis.logging：适配器模式+代理。适配器模式是为了将自己与其它的东西融合到一起而设计的。比如mybatis：为了融合各大日志框架体系，不可能让日志框架做出改动，而自己也不好适应各个框架。所以自己定义了一套日志体系接口，然后把每套日志框架做一个适配，这样以后即使有新的框架产生了，只需要实现接口，再配置就行了，就不用修改原来的代码。代理模式体现在日志打印，使用代理就可以在方法前后进行打印。
org.apache.ibatis.datasource：工厂模式。为了生产复杂的对象由工厂代劳，一方面简化操作。另一方面为了解耦。
org.apache.ibatis.cache：装饰器模式。如果想要对象具有多种行为能力的话使用继承或者接口就会非常复杂。比如我有一个产品。如果遵循设计模式的原则的话，我想要给它增加日志的能力，多一个继承类，我想增加入库的能力，一个类，我想增加活动的能力，再一个类。此时3个继承的了。如果我既想有日志又想有活动的能力。这样组合的话有很多种，而使用装饰器模式始终只有3种，具体实现请百度。
